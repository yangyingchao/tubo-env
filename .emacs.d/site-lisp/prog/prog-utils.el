;;; prog-utils.el --- Brief introduction here. -*- lexical-binding: t; -*-

;;; Commentary:

;;; Code:
(require 'use-package)
(require '02-functions)
(require 'cl)
(require 'ivy)
(require 'swiper)
(require 'imenu)
(require 'counsel)
(require 'lsp-mode)
(require 'yc-utils)



(defun yc/remove-empty-lines (&optional pos)
  "Remove empty lines around this position..."
  (interactive)
  (save-excursion
    (if pos
        (goto-char pos))

    ;; Find next non new-line and non-empty character
    (skip-chars-forward " 	\n")
    (setq pos (point))
    (when
        (<= (skip-chars-backward " 	\n") -2)
      (delete-region (1+ (point)) pos))))

(use-package srecode/find
  :commands (srecode-load-tables-for-mode))

(use-package semantic/util-modes
  :commands (semantic-stickyfunc-tag-to-stick))

(use-package srecode/insert
  :commands (srecode-insert))

(defun yc/insert-single-comment ()
  "Insert signle line of comment using srecode."
  (interactive)
  (condition-case err
      (progn
        (srecode-load-tables-for-mode major-mode)
        (yc/remove-empty-lines (point-min))
        (srecode-insert "declaration:comment-single-line"))
    (error
     (progn
       (PDEBUG "ERROR:" err)
       (insert " /* */")))))



(defun yc/insert-empty-template ()
  "Make header based on srecode."
  (interactive)
  (save-excursion
    (srecode-load-tables-for-mode major-mode)
    (srecode-insert "file:empty")
    (delete-trailing-whitespace)))

(defun yc/header-make ()
  "Make header based on srecode."
  (interactive)
  (progn;save-excursion
    (goto-char (point-min))
    (while (looking-at (or comment-start-skip comment-start))
      (forward-line))
    (condition-case err
        (progn
          (srecode-load-tables-for-mode major-mode)
          (yc/remove-empty-lines (point-min))

          (srecode-insert "file:fileheader")
          (yc/remove-empty-lines (point-max))
          (goto-char (point-max))
          (srecode-insert "file:fileheader_end"))
      (error (srecode-insert "file:filecomment")))
    )
  (delete-trailing-whitespace))

(defun get-address ()
  "Get address"
  (let ((r-match-addr  (rx (+ space) (group (+ alnum)) ":" space)) )
  (if (looking-at r-match-addr)
      (let* ((m-data (match-data 1))
             (addr-str (buffer-substring-no-properties (nth 2 m-data) (nth 3 m-data))))
        (string-to-number addr-str 16)))))

(defun yc/asm-post-process-objdump ()
  "Post process for asm file generated by `objdump'."
  (PDEBUG "asm post process for objdump")
  (let ((r-match-func  (rx bol  (+ alnum) (+ space) "<" (+ (or "_" alnum)) ">:" eol))
        (r-match-codes (rx ":" (+ space) (* (repeat 2 alnum) space ) (* space)))
        (r-match-offset (rx "+" "0x" (group (+ alnum))  ">"))
        pos )

    ;; first, add a space around "+"
    (save-excursion
      (while (search-forward-regexp r-match-offset nil t)
        (replace-match "+ 0x\\1 >"))
      )

    ;; then, remove instruction codes...
    (save-excursion
      (while (search-forward-regexp r-match-codes nil t)
        (replace-match ":	")))

    ;; last, calculate offset for instruction addresses.
    (save-excursion
      (while (setq pos (search-forward-regexp r-match-func nil t))
        (let* ((pos (1+ pos))
               (end (or (search-forward-regexp r-match-func nil t)
                        (point-max))))
          (goto-char end)
          (setq end (point-at-eol -1)) ;; update end position, we'll go back here later.
          (goto-char pos)
          (aif (get-address)
              (while (<= pos end)
                (goto-char pos)
                (unless (looking-at-p (rx (or (: bol eol)
                                              (: (* space)";" ))))
                  (let* ((addr (get-address))
                         (tmp-string (format "0x%x" (- addr it)))
                         (off-string (format "%s%s" tmp-string
                                             (make-string
                                              (- 7 (length tmp-string)) ? ))))
                    (insert off-string)
                    (setq end (+ end (length off-string)))))
                (setq pos (point-at-bol 2))))
          (goto-char end)
          (forward-line -1))))))

(defun yc/asm-post-process-gdb ()
  "Post process for asm file generated by `gdb'."
  (PDEBUG "asm post process for gdb")
  (let ((r-match-offset (rx "<" (group "+" (+ digit)  ">:")))
        (r-match-offset-funcall (rx (group "<" (+? (or alnum "_"))) "+"
                                    (group (+ digit)  ">") eol) ))

    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp r-match-offset nil t)
        ;; (replace-match "< \\1\t\t")
        (let* ((str (match-string 1)))
          (replace-match (format "< %s%s" str (if (> (length str) 5) "" "\t")))
          )
        ))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp r-match-offset-funcall nil t)
        (replace-match "\\1 +\\2")))))

(autoload 'yc/cpp-demangle-buffer "c-tuils" nil t)

;;;###autoload
(defun yc/asm-post-process ()
  "Add offset to current file."
  (interactive)
  (save-excursion
    (yc/cpp-demangle-buffer)
    (goto-char (point-min))

    (if (looking-at-p (rx "Dump of assembler code for function"))
        (yc/asm-post-process-gdb)
      (yc/asm-post-process-objdump))))

(use-package lsp-mode
  :commands (lsp--cur-workspace-check lsp--imenu-filter-symbols
                                      lsp--capability
                                      lsp--get-document-symbols
                                      lsp--get-symbol-type
                                      lsp--imenu-hierarchical-p
                                      lsp--imenu-symbol-lessp
                                      lsp--position-to-point))


(use-package imenu
  :commands (imenu--subalist-p imenu--make-index-alist))

(use-package counsel
  :commands (counsel-imenu-categorize-functions counsel-semantic-format-tag
                                                counsel-semantic-tags))

(defvar yc/imenu--overlays nil
  "Store overlays.")

(defun yc/imenu--cleanup ()
  "Clean up the overlays."
  (while yc/imenu--overlays
    (delete-overlay (pop yc/imenu--overlays))))

(defun yc/imenu--add-overlay ()
  "Add overlays for RE regexp in visible part of the current buffer.
BEG and END, when specified, are the point bounds.
WND, when specified is the window."
  (let ((ov  (make-overlay
              (line-beginning-position)
              (1+ (line-end-position)))))
    (overlay-put ov 'face 'swiper-line-face)
    (push ov yc/imenu--overlays)
    ))

(defun yc/counsel-imenu-update-fn()
  "Called when `ivy' input is updated."
  (with-ivy-window
    (yc/imenu--cleanup)
    (when (> (length (ivy-state-current ivy-last)) 0)
      (let* ((regexp-or-regexps (funcall ivy--regex-function ivy-text))
             (regexps
              (if (listp regexp-or-regexps)
                  (mapcar #'car (cl-remove-if-not #'cdr regexp-or-regexps))
                (list regexp-or-regexps))))

        (dolist (re regexps)
          (let* ((re (replace-regexp-in-string
                      "    " "\t"
                      re))
                 (num (get-text-property 0 'swiper-line-number (ivy-state-current ivy-last))))
            (unless (memq this-command '(ivy-yank-word
                                         ivy-yank-symbol
                                         ivy-yank-char
                                         scroll-other-window))
              (when (cl-plusp num)
                (goto-char num)
                (isearch-range-invisible (line-beginning-position)
                                         (line-end-position))
                (unless (and (>= (point) (window-start))
                             (<= (point) (window-end (ivy-state-window ivy-last) t)))
                  (recenter 3))
                ))
            (yc/imenu--add-overlay)))))))

(defun yc/lsp--imenu-create-hierarchical-index (symbols)
  "Create imenu index for hierarchical SYMBOLS.

SYMBOLS are a list of DocumentSymbol messages.

Return a nested alist keyed by symbol names. e.g.

   ((\"SomeClass\" (\"(Class)\" . 10)
                 (\"someField (Field)\" . 20)
                 (\"someFunction (Function)\" . 25)
                 (\"SomeSubClass\" (\"(Class)\" . 30)
                                  (\"someSubField (Field)\" . 35))
    (\"someFunction (Function)\" . 40))"
  (let ((symbols (lsp--imenu-filter-symbols symbols)))
    (seq-filter
     #'identity
     (seq-map #'yc/lsp--symbol-to-hierarchical-imenu-elem
              (lsp--imenu-filter-symbols symbols)
              ;; (seq-sort #'lsp--imenu-symbol-lessp
              ;;           (lsp--imenu-filter-symbols symbols))
              ))))

(defun yc/counsel-imenu-get-candidates-from (alist &optional prefix)
  "Create a list of (key . value) from ALIST.
PREFIX is used to create the key."
  (progn
    (cl-mapcan (lambda (elm)
                 (PDEBUG "ELM:" elm
                   "PFX: " prefix)
                 (if (imenu--subalist-p elm)
                     (progn
                       (PDEBUG "SUBALIST")
                       (yc/counsel-imenu-get-candidates-from
                        (cl-loop for (e . v) in (cdr elm) collect
                                 (cons e (if (integerp v) (copy-marker v) v)))
                        ;; pass the prefix to next recursive call
                        (concat prefix (if prefix ".") (car elm))))
                   (let ((key (concat
                               (when prefix
                                 (if (get-text-property 0 'face prefix)
                                     (format " (%s) " prefix)

                                   (concat
                                    (propertize prefix 'face 'ivy-grep-info)
                                    ": ")))
                               (let ((name (car elm)))
                                 (PDEBUG "SS" (get-text-property 0 'face name)
                                         "KK" (yc/imenu--get-symbol-face prefix))
                                 (if (get-text-property 0 'face name)
                                     name
                                   (propertize name 'face (yc/imenu--get-symbol-face prefix))
                                   )
                                 )
                               )))
                     (list (cons key
                                 (put-text-property
                                  0 1 'swiper-line-number
                                  (cond
                                   ((markerp (cdr elm))
                                    (marker-position (cdr elm)))
                                   ((numberp (cdr elm))
                                    (cdr elm))
                                   ((overlayp (cdr elm))
                                    (overlay-start (cdr elm)))
                                   (t (PDEBUG "??" (cdr elm))
                                      (error "??"))
                                   )
                                   key))))))
               alist)))


(cdsq yc/lsp--symbol-face
  '(;; (1 . "File")
    (2 . font-lock-constant-face) ;; "Module"
    (3 . font-lock-constant-face) ;; "Namespace"
    ;; (4 . "Package")
    (5 . font-lock-type-face) ;;"Class"
    (6 . font-lock-function-name-face) ;; "Method"
    (7 . font-lock-variable-name-face) ;; "Property"
    (8 . font-lock-variable-name-face)
    (9 . font-lock-function-name-face) ;; "Constructor"
    (10 . font-lock-constant-face) ;; "Enum"
    (11 . font-lock-function-name-face) ;; "Interface"
    (12 . font-lock-function-name-face) ;; Function
    (13 . font-lock-variable-name-face) ;; Variables
    (14 . font-lock-constant-face)      ;; Constant
    (15 . font-lock-string-face)        ;;
    ;; (16 . "Number")
    ;; (17 . "Boolean")
    ;; (18 . "Array")
    ;; (19 . "Object")
    ;; (20 . "Key")
    ;; (21 . "Null")
    ;; (22 . "Enum Member")
    (23 . font-lock-type-face) ;; "Struct"
    ;; (24 . "Event")
    ;; (25 . "Operator")
    ;; (26 . "Type Parameter")
    )
  "")

(defun yc/lsp--get-symbol-face (sym)
  "The face for the kind of SYM."
  (-> (gethash "kind" sym)
      (assoc yc/lsp--symbol-face)
      (cdr)

      (or 'default)))


(cdsq yc/imenu--symbol-face
  '(
    ("Packages" . font-lock-constant-face)
    ("Module" . font-lock-constant-face)
    ("Class" . 'ont-lock-type-face) ;;"Class"
    ("Module" . font-lock-constant-face) ;;"Class"
    (6 . font-lock-function-name-face) ;; "Method"
    ("Variables" . font-lock-variable-name-face) ;; "Property"
    ("Variable" . font-lock-variable-name-face) ;; "Property"
    (8 . font-lock-variable-name-face)
    (9 . font-lock-function-name-face) ;; "Constructor"
    (10 . font-lock-constant-face) ;; "Enum"
    ("Functions" . font-lock-function-name-face) ;; "Interface"
    ("Function" . font-lock-function-name-face) ;; "Interface"
    (12 . font-lock-function-name-face) ;; Function
    (13 . font-lock-variable-name-face) ;; Variables
    (14 . font-lock-constant-face)      ;; Constant
    (15 . font-lock-string-face)        ;;
    ;; (16 . "Number")
    ;; (17 . "Boolean")
    ;; (18 . "Array")
    ;; (19 . "Object")
    ;; (20 . "Key")
    ;; (21 . "Null")
    ;; (22 . "Enum Member")
    (23 . font-lock-type-face) ;; "Struct"
    ;; (24 . "Event")
    ;; (25 . "Operator")
    ;; (26 . "Type Parameter")
    )
  "")

(defun yc/imenu--get-symbol-face (sym)
  "The face for the kind of SYM."
  (-> sym
      (assoc yc/imenu--symbol-face)
      (cdr)
      (or 'default)))

(define-inline lsp--point-to-marker (p)
  (inline-quote (save-excursion (goto-char ,p) (point-marker))))

(defun lsp--symbol-get-start-point (sym)
   "Get the start point of the name of SYM.

 SYM can be either DocumentSymbol or SymbolInformation."

   (let* ((location (gethash "location" sym))
          (name-range (or (and location (gethash "range" location))
                          (gethash "selectionRange" sym)))
          (start-point (lsp--position-to-point
                        (gethash "start" name-range))))
     (if imenu-use-markers (lsp--point-to-marker start-point) start-point)))

(defun yc/lsp--symbol-to-hierarchical-imenu-elem (sym)
  "Convert SYM to hierarchical imenu elements.

SYM is a DocumentSymbol message.

Return cons cell (\"symbol-name (symbol-kind)\" . start-point) if
SYM doesn't have any children. Otherwise return a cons cell with
an alist

  (\"symbol-name\" . ((\"(symbol-kind)\" . start-point)
                    cons-cells-from-children))"
  (if (string= "Other" (lsp--get-symbol-type sym))
      nil
    (let* ((start-point (lsp--symbol-get-start-point sym))
           (name (gethash "name" sym))
           (ret (if (seq-empty-p (gethash "children" sym))
                    (cons (concat
                           (propertize (lsp--get-symbol-type sym) 'face 'ivy-grep-info)
                           ": "
                           (propertize name  'face (yc/lsp--get-symbol-face sym))
                           )
                          start-point)
                  (cons   (propertize name  'face (yc/lsp--get-symbol-face sym))
                          (cons (cons
                                 (propertize (lsp--get-symbol-type sym)  'face 'ivy-grep-info)
                                 start-point)
                                (yc/lsp--imenu-create-hierarchical-index (gethash "children" sym)))))))
      (PDEBUG "RET: " ret)
      ret)))

(defun yc/lsp--symbol-to-imenu-elem (sym)
  "Convert SYM to imenu element.

SYM is a SymbolInformation message.

Return a cons cell (full-name . start-point)."
  (PDEBUG "SYM: " sym)

  (let* ((start-point (lsp--symbol-get-start-point sym))
         (name (gethash "name" sym))
         (container (gethash "containerName" sym))
         (ret (cons (if (and lsp-imenu-show-container-name container)
                        (concat container lsp-imenu-container-name-separator name)
                      name)
                    start-point)))

    (PDEBUG "RET2: " ret)
    ret))


(defun yc/counsel-imenu-get-candidates (alist &optional prefix)
  "Create a list of (key . value) from ALIST.
PREFIX is used to create the key."
  (let ((yc/debug-log-limit -1))
    (PDEBUG "ALIST:" alist))

  ;; (yc/counsel-imenu-get-candidates-from alist prefix)

  (condition-case msg
      (yc/counsel-imenu-get-candidates-from alist prefix)
    (error (progn (PDEBUG "FAIL: " msg)    nil)))
  )


(defvar-local yc/cached-tags nil "last cached index.")
(defvar-local yc/document-tags-tick -1 "last tick of modification.")

(defun yc/tags-from-imenu ()
  "Get tags from imenu.
If NO-CACHED is true, do not use cached value."
  (interactive)
  (unless (featurep 'imenu)
    (require 'imenu nil t))

  (let* ((imenu-auto-rescan t)
         (imenu-auto-rescan-maxout (if current-prefix-arg
                                       (buffer-size)
                                     imenu-auto-rescan-maxout))
         (items (imenu--make-index-alist t))
         (items (delete (assoc "*Rescan*" items) items))
         (items (if (eq major-mode 'emacs-lisp-mode)
                    (counsel-imenu-categorize-functions items)
                  items))
         (tags (yc/counsel-imenu-get-candidates items)))

    (if (called-interactively-p 'interactive)
        (let ((yc/debug-log-limit -1))
          (PDEBUG "IMENU-FUNC: " imenu-create-index-function)
          (PDEBUG "TAGS: " tags)))

    (if tags
        (PDEBUG "TAGS from imenu"))
    tags))

(defun yc/tags-from-lsp ()
  "Get tags from imenu.
If NO-CACHED is true, do not use cached value."
  (interactive)
  (let (tags)
    (when (and (bound-and-true-p lsp-mode)
               (lsp--capability "documentSymbolProvider"))

      (PDEBUG "Refreshing tags from LSP..." )
      (condition-case var
          (let* ((symbols (lsp--get-document-symbols))
                 (filted-symbols (lsp--imenu-filter-symbols symbols))
                 (items
                  (if (lsp--imenu-hierarchical-p symbols)
                      (yc/lsp--imenu-create-hierarchical-index symbols)
                    (seq-map (lambda (nested-alist)
                               (cons (car nested-alist)
                                     (seq-map #'yc/lsp--symbol-to-imenu-elem (cdr nested-alist))))
                             (seq-group-by #'lsp--get-symbol-type filted-symbols)))))

            (when (called-interactively-p 'interactive)
              (PDEBUG "SYM: " symbols)
              (PDEBUG "ITEMS" items))

            (setq tags (yc/counsel-imenu-get-candidates items)))

        (error (PDEBUG "ERROR: " var)))

      (if (called-interactively-p 'interactive)
          (let ((yc/debug-log-limit 4096))
            (PDEBUG "LSP-ITEMS: " tags))))

    (if tags
        (PDEBUG "TAGS from LSP"))

    tags))

(defun yc/tags-from-outline ()
  "Get tags from outline."
  (interactive)
  (let (tags)
    (when (member major-mode '(org-mode markdown-mode latex-mode))
      (PDEBUG "Refreshing tags from outline..." )

      (condition-case var
          (let* ((settings (cdr (assq major-mode counsel-outline-settings)))
                 (outlines (counsel-outline-candidates settings)))
            (PDEBUG "OUTLINES:" outlines)
            (dolist (item outlines)
              (let ((key (car item)))
                (push (cons key
                            (put-text-property
                             0 1 'swiper-line-number
                             (marker-position (cdr item)) key)) tags)
                )))

        (error (PDEBUG "ERROR: " var)))

      (if (called-interactively-p 'interactive)
          (let ((yc/debug-log-limit 4096))
            (PDEBUG "LSP-ITEMS: " tags))))
    (if tags
        (PDEBUG "TAGS from outline"))
    (nreverse tags)))

(defun yc/show-methods-dwim ()
  "Show methods found in current file, using any possible way.."
  (interactive)

  ;; for unsupported modes, simply use imenu.
  (if (member major-mode '(pdf-view-mode))
      (imenu-choose-buffer-index)

    ;; reset tags-tick to force refresh tags.
    (if current-prefix-arg
        (setq yc/document-tags-tick -1))

    ;; update tags should happen only when timestamp changes
    (when (or (not yc/cached-tags)
              (not (= yc/document-tags-tick
                  (buffer-chars-modified-tick))))

      (PDEBUG "Refreshing tags..." )
      (setq yc/document-tags-tick (buffer-chars-modified-tick)
            yc/cached-tags
            (sort
             (or (yc/tags-from-lsp)
                 (yc/tags-from-outline)
                 (yc/tags-from-imenu))

                  (lambda (x y)
                    (PDEBUG "X" x)
                    (PDEBUG "Y" x)
                    (<
                     (get-text-property 0 'swiper-line-number (car x))
                     (get-text-property 0 'swiper-line-number (car y))))))

      (if (called-interactively-p 'interactive)
          (let ((yc/debug-log-limit 4096))
            (PDEBUG "TAG ITEMS: " yc/cached-tags))))

    (unless yc/cached-tags
      (error "Failed to get tags"))

    (let ((yc/debug-log-limit -1))
      (PDEBUG "CACHED_TAGS: " yc/cached-tags))

    ;; TODO: should recenter to a tag near current position...
    (let ((position (point))
          res)
      (unwind-protect
              (setq res
                    (ivy-read "tag: " yc/cached-tags
                              :update-fn #'yc/counsel-imenu-update-fn
                              :action (lambda (x)
                                        (recenter 3))
                              :caller 'yc/counsel-imenu))

            (unless res
              (goto-char position))
            (yc/imenu--cleanup)))))



(defvar xref-ivy-last nil "Last state used by ivy-xref-show-xrefs.")

(defun yc/ivy-xref-show-xrefs-adv (&rest args)
  "Advice for 'ivy-xref-show-xrefs'.
Call FUNC which is 'ivy-xref-show-xrefs with ARGS."
  (setq xref-ivy-last ivy-last))

(defun yc/return-reflist ()
  "Return to last reference list."
  (interactive)
  (unless xref-ivy-last
    (error "Stack is empty"))

  (let ((ivy-last xref-ivy-last) )
    (ivy-resume)))


(defun lsp-ui-find-workspace-symbol (pattern)
  "List project-wide symbols matching the query string PATTERN."
  (interactive (list (read-string
                      "workspace/symbol: "
                      nil 'xref--read-pattern-history))))

(defun yc/find-definitions-xref ()
  "Description."
  (interactive)

  (PDEBUG "T: " (xref-find-backend))
  (PDEBUG "F: " (xref-backend-identifier-at-point (xref-find-backend)))

  (condition-case msg
      (let ((identifier (xref-backend-identifier-at-point (xref-find-backend))))
        (PDEBUG "ID: " identifier "LEN: " (length identifier))
        (if (and identifier
                 (> (length identifier) 0))
            (xref--find-definitions identifier nil)

          ;; if identifier is invalid, try apropos...
          (let ((pattern (read-string
                          "workspace/symbol: "
                          nil 'xref--read-pattern-history)) )
            (xref--find-xrefs pattern 'apropos pattern nil)))

        ;; Don't use marker-ring of xref, I'm using my own stack.
        (unless (ring-empty-p xref--marker-ring)
          (ring-remove xref--marker-ring 0))
        t)

    ('error (progn (PDEBUG "Failed to find definition with xref.") nil))))

(defvar-local yc/find-def-func-list nil
  "List of functions can be used when finding definitions.
If a function succeeded in finding a definition, it should push a method which can
  be used to return to previous position, and then returns t. Otherwise, return nil.
Also, ")

(setq-default yc/find-def-func-list '(yc/find-definitions-xref))


(defun yc/prog-try-function-list (func-list tip)
  "Call functions in `FUNC-LIST..."
  (PDEBUG "FL: " func-list)
  (catch 'd-found
    (dolist (func func-list)
      (condition-case var
          (progn
            (PDEBUG "Func: " func)
            (if (and func (funcall func))
                (throw 'd-found t)
              (PDEBUG tip ":"
                (format "%s returns nil:, trying others.."
                        (symbol-name func)))))

        (error (PDEBUG tip ":" func var))))

    (error "Failed to %s" tip)))

(defun yc/find-definitions ()
  "Goto definition of symbol."
  (interactive)
  (let ((m (point-marker)))
    (condition-case msg
        (progn
          (yc/prog-try-function-list yc/find-def-func-list "find-definitions")
          (yc/push-stack m))
      ('error (PDEBUG "Failed to find definition.")))))


(defun yc/push-find-func (func)
  "Description."
  (push func yc/find-def-func-list))


(defun yc/find-references-xref ()
  "Description."
  (interactive)

  (condition-case msg
      (xref-find-references (xref-backend-identifier-at-point (xref-find-backend)))
    ('error (PDEBUG "Failed to find reference with xref."))))

(defvar-local yc/find-ref-func-list '(yc/find-references-xref)
  "List of functions can be used when finding references.
Return t if succeeded, or nil otherwise.")


(defun yc/find-implementation ()
  "Description."
  (interactive)
  (if (bound-and-true-p lsp-mode)
      (let ((m (point-marker)) )
        (lsp-find-implementation)
        (yc/push-stack m))

    (error "Only works for lsp-mode for now")))

(defun yc/find-references ()
  "Goto definition of symbol."
  (interactive)
  (let ((m (point-marker)))
    (condition-case msg
        (progn
          (yc/prog-try-function-list yc/find-ref-func-list "find-references")
          (yc/push-stack m))
      ('error (PDEBUG "Failed to find reference.")))))

(defun yc/find-header-lsp ()
  "Find header file based on lsp."
  (interactive)

  (unless lsp-mode
    (error "lsp-mode not enabled for this buffer"))

  (let ((overlays (overlays-in (point-at-bol) (point-at-eol))))
    (PDEBUG "OVERLAYS:" overlays)
    (catch 'p-found
      (dolist (overlay overlays)
        (let ((pops (overlay-properties overlay)))
          (PDEBUG "POPS: " pops)
          (cl-case (overlay-get overlay 'category)
            ('default-button
              (let* ((action (overlay-get overlay 'action))
                     (res (funcall action overlay)))
                (PDEBUG "ACTION: " action
                  "RES:  " res)
                (if res
                    (throw 'p-found t)))))))
      nil)))


(defun yc/open-header ()
  "Open header file lied under current PT."
  (interactive)

  (let ((m (point-marker)))
    (condition-case msg
        (progn
          (yc/prog-try-function-list
           '(yc/find-header-lsp yc/find-definitions-xref)
           "find-header")
          (yc/push-stack m))
      ('error (PDEBUG "Failed to find header.")))))

(defun yc/return-func()
  "Return to previous tag."
  (interactive)

  (when (ring-empty-p yc/marker-stack)
    (error "Marker stack is empty"))

  (let ((marker (ring-remove yc/marker-stack 0)))
    (switch-to-buffer (or (marker-buffer marker)
                          (error "The marked buffer has been deleted")))
    (goto-char (marker-position marker))
    (set-marker marker nil nil)
    (run-hooks 'xref-after-return-hook)))

(defun yc/store-current-location ()
  "Store current location (PT)."
  (interactive)
  (yc/push-stack)
  (if (called-interactively-p 'interactive)
      (message "Location saved...")))


(defun yc/wip-comment ()
  "Add WIP comment.
WIP is used as keyword to prevent commit unfinished task, by using git hook.

Save following codes into .git/pre-commit, to make it work:

git diff --cached HEAD | grep \" WIP:\" > /dev/null
if [ $? -eq 0 ]; then
    echo \"WIP is detected...\"
    exit 1
fi

Don not forget to make pre-commit executable."
  (interactive)
  (save-excursion
    (goto-char (point-at-eol))
    (insert " "
            (comment-padright comment-start comment-add )
            "WIP: "
            (read-from-minibuffer "WIP: ")
            comment-end)))

(provide 'prog-utils)

;; Local Variables:
;; coding: utf-8
;; indent-tabs-mode: nil
;; End:

;;; prog-utils.el ends here
